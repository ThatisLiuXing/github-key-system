# 卡密系统原理详解

## 目录

1. [系统概述](#系统概述)
2. [核心算法](#核心算法)
3. [数据流分析](#数据流分析)
4. [安全机制](#安全机制)
5. [扩展性设计](#扩展性设计)

## 系统概述

本系统是一个基于 GitHub 生态的轻量级卡密（License Key）管理系统，利用 GitHub Actions 进行自动化生成，GitHub Pages 提供验证服务，实现零成本、易部署的授权码解决方案。

### 架构特点

```
┌─────────────────────────────────────────────────────────────┐
│                        用户层                                │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │  管理员      │    │  普通用户    │    │  API 调用   │     │
│  │  (生成卡密)  │    │  (验证卡密)  │    │  (集成)     │     │
│  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘     │
└─────────┼──────────────────┼──────────────────┼────────────┘
          │                  │                  │
          ▼                  ▼                  ▼
┌─────────────────────────────────────────────────────────────┐
│                      GitHub 平台层                           │
│  ┌─────────────────┐    ┌─────────────────┐                 │
│  │  GitHub Actions │    │  GitHub Pages   │                 │
│  │  (工作流执行)    │    │  (静态页面托管)  │                 │
│  └────────┬────────┘    └────────┬────────┘                 │
│           │                      │                          │
│           ▼                      ▼                          │
│  ┌─────────────────────────────────────┐                    │
│  │        GitHub Repository            │                    │
│  │  ┌─────────────┐  ┌─────────────┐  │                    │
│  │  │ keys.json   │  │ index.html  │  │                    │
│  │  │ (卡密数据)   │  │ (验证页面)   │  │                    │
│  │  └─────────────┘  └─────────────┘  │                    │
│  └─────────────────────────────────────┘                    │
└─────────────────────────────────────────────────────────────┘
```

## 核心算法

### 1. 卡密生成算法

#### 随机数生成

```javascript
function generateKey(prefix, length) {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let key = prefix;
    const keyLength = length - prefix.length;
    
    for (let i = 0; i < keyLength; i++) {
        if (i > 0 && i % 4 === 0) {
            key += '-';
        }
        key += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    
    return key;
}
```

**算法说明**:
- 字符集: 36 个字符（26 字母 + 10 数字）
- 熵值计算: 每个字符提供 log₂(36) ≈ 5.17 bits 的熵
- 16 位卡密总熵值: 16 × 5.17 ≈ 82.7 bits
- 理论组合数: 36¹⁶ ≈ 7.96 × 10²⁴

#### 格式设计

```
PREFIX-XXXX-XXXX-XXXX-XXXX
│      │    │    │    │
│      │    │    │    └── 第 4 组 (4字符)
│      │    │    └─────── 第 3 组 (4字符)
│      │    └──────────── 第 2 组 (4字符)
│      └───────────────── 第 1 组 (4字符)
└──────────────────────── 前缀 (可选)
```

**设计理由**:
1. **分组显示**: 每 4 字符一组，便于阅读和输入
2. **分隔符**: 使用 `-` 分隔，清晰易识别
3. **前缀**: 支持自定义前缀，便于分类管理
4. **大小写**: 统一大写，避免混淆

### 2. 哈希签名算法

```javascript
function createHash(key) {
    return crypto
        .createHmac('sha256', secretKey)
        .update(key)
        .digest('hex')
        .substring(0, 16);
}
```

**算法说明**:
- 算法: HMAC-SHA256
- 密钥: 存储在 GitHub Secrets 中的 `KEY_SECRET`
- 输出: 16 位十六进制字符串（64 bits）
- 用途: 数据完整性校验，防止篡改

**安全特性**:
1. **抗碰撞**: SHA-256 提供 256 位安全强度
2. **密钥保护**: HMAC 需要密钥才能生成有效哈希
3. **单向性**: 无法从哈希反推原始卡密

### 3. 数据结构设计

```typescript
interface LicenseKey {
    // 卡密字符串
    key: string;
    
    // 哈希签名（用于验证完整性）
    hash: string;
    
    // 创建时间（ISO 8601 格式）
    createdAt: string;
    
    // 是否已使用
    used: boolean;
    
    // 使用时间（未使用为 null）
    usedAt: string | null;
    
    // 使用者信息（未使用为 null）
    usedBy: {
        userAgent: string;
        ip: string;
        timestamp: string;
    } | null;
}
```

## 数据流分析

### 生成流程

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 触发    │───▶│ 参数    │───▶│ 生成    │───▶│ 签名    │
│ 工作流  │    │ 解析    │    │ 随机数  │    │ 计算  │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                                                  │
┌─────────┐    ┌─────────┐    ┌─────────┐        │
│ 提交    │◀───│ 文件    │◀───│ 组装    │◀───────┘
│ 仓库    │    │ 写入    │    │ 数据    │
└─────────┘    └─────────┘    └─────────┘
```

**详细步骤**:

1. **触发工作流**
   - 手动触发: 通过 GitHub 界面点击 "Run workflow"
   - API 触发: 通过 GitHub API 发送请求
   - 定时触发: 配置 schedule 事件（可选）

2. **参数解析**
   ```yaml
   inputs:
     count:    # 生成数量
     prefix:   # 卡密前缀
     length:   # 卡密长度
   ```

3. **随机数生成**
   - 使用 `Math.random()` 生成伪随机数
   - 从字符集中选取对应字符
   - 每 4 位插入分隔符

4. **签名计算**
   - 使用 HMAC-SHA256 算法
   - 密钥来自环境变量 `KEY_SECRET`
   - 截取前 16 位作为哈希值

5. **数据组装**
   ```json
   {
     "key": "PROD-A1B2-C3D4-E5F6",
     "hash": "a1b2c3d4e5f67890",
     "createdAt": "2024-01-15T08:30:00.000Z",
     "used": false,
     "usedAt": null,
     "usedBy": null
   }
   ```

6. **文件写入**
   - 读取现有 `keys.json`
   - 合并新卡密数据
   - 写入文件系统

7. **提交仓库**
   - 配置 Git 用户信息
   - 添加文件到暂存区
   - 创建提交并推送

### 验证流程

```
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 用户    │───▶│ 输入    │───▶│ 格式    │───▶│ 查询    │
│ 输入    │    │ 接收    │    │ 化处理  │    │ 数据    │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
                                                  │
┌─────────┐    ┌─────────┐    ┌─────────┐        │
│ 显示    │◀───│ 更新    │◀───│ 状态    │◀───────┘
│ 结果    │    │ 统计    │    │ 检查    │
└─────────┘    └─────────┘    └─────────┘
```

**详细步骤**:

1. **输入接收**
   - 监听输入框的 `input` 事件
   - 实时格式化输入内容

2. **格式化处理**
   ```javascript
   // 转大写，移除非字母数字字符
   value = input.toUpperCase().replace(/[^A-Z0-9]/g, '');
   
   // 每 4 位插入分隔符
   for (let i = 0; i < value.length; i++) {
       if (i > 0 && i % 4 === 0) formatted += '-';
       formatted += value[i];
   }
   ```

3. **数据查询**
   - 加载 `keys.json` 文件
   - 在内存中建立索引（可选优化）
   - 查找匹配的卡密

4. **状态检查**
   ```javascript
   if (!keyData) {
       return { valid: false, code: 'NOT_FOUND' };
   }
   if (keyData.used) {
       return { valid: false, code: 'ALREADY_USED' };
   }
   ```

5. **更新统计**
   - 更新已使用计数
   - 更新界面显示

6. **显示结果**
   - 成功: 显示绿色提示
   - 失败: 显示红色提示和原因

## 安全机制

### 1. 密钥保护

```
GitHub Secrets
│
├── KEY_SECRET (用于 HMAC 签名)
│
└── 访问控制
    ├── 仅 Actions 可读取
    ├── 不在日志中显示
    └── 加密存储
```

**安全措施**:
- 使用 GitHub Secrets 存储敏感信息
- 密钥不会暴露在代码或日志中
- 支持密钥轮换

### 2. 数据完整性

```
原始数据 ──▶ HMAC-SHA256 ──▶ 哈希值
                                │
存储数据 ──▶ HMAC-SHA256 ──▶ 对比验证
```

**验证流程**:
1. 读取存储的哈希值
2. 重新计算当前数据的哈希
3. 对比两个哈希值
4. 不匹配则提示数据可能被篡改

### 3. 防重放攻击

```javascript
// 标记卡密为已使用
keyData.used = true;
keyData.usedAt = new Date().toISOString();
keyData.usedBy = {
    userAgent: navigator.userAgent,
    timestamp: new Date().toISOString()
};
```

**防护机制**:
- 每个卡密只能使用一次
- 记录使用时间和设备信息
- 重复验证返回已使用状态

### 4. 访问控制

| 场景 | 权限 | 说明 |
|------|------|------|
| 私有仓库 | 需登录 | GitHub Pages 需要身份验证 |
| 公有仓库 | 公开访问 | 任何人都可以访问验证页面 |
| Actions | 需写入权限 | 只有仓库成员可以触发工作流 |

## 扩展性设计

### 1. 批量生成优化

```javascript
// 使用 Set 去重
const existingKeys = new Set();

while (generated < count) {
    const key = generateKey(prefix, length);
    if (!existingKeys.has(key)) {
        existingKeys.add(key);
        keys.push(createKeyData(key));
        generated++;
    }
}
```

### 2. 数据分片

当卡密数量很大时，可以分片存储:

```
keys/
├── 2024-01.json
├── 2024-02.json
└── 2024-03.json
```

### 3. 过期机制

```javascript
// 添加过期时间字段
{
    "key": "PROD-XXXX-XXXX-XXXX",
    "expiresAt": "2024-12-31T23:59:59.000Z"
}

// 验证时检查
function isExpired(keyData) {
    if (!keyData.expiresAt) return false;
    return new Date() > new Date(keyData.expiresAt);
}
```

### 4. 使用限制

```javascript
// 限制使用次数
{
    "key": "PROD-XXXX-XXXX-XXXX",
    "maxUses": 5,
    "useCount": 2
}

// 限制使用设备
{
    "key": "PROD-XXXX-XXXX-XXXX",
    "allowedDevices": ["device-1", "device-2"]
}
```

### 5. 实时同步方案

由于 GitHub Pages 是静态托管，前端无法直接写入数据。实现实时同步的方案:

**方案 A: 后端服务器**
```
前端 ──▶ 后端 API ──▶ 数据库
```

**方案 B: GitHub API**
```
前端 ──▶ GitHub API ──▶ 更新文件
```

**方案 C: 第三方服务**
```
前端 ──▶ Firebase/Supabase ──▶ 实时数据库
```

## 性能分析

### 生成性能

| 数量 | 预计时间 | 内存占用 |
|------|----------|----------|
| 100 | < 1s | < 1MB |
| 1,000 | < 2s | < 5MB |
| 10,000 | < 5s | < 20MB |

### 查询性能

| 数据量 | 查询时间 | 优化方案 |
|--------|----------|----------|
| 1,000 | < 10ms | 无需优化 |
| 10,000 | < 50ms | 内存索引 |
| 100,000 | < 200ms | 分片加载 |

## 总结

本系统通过合理利用 GitHub 的免费服务，实现了一个简单、可靠的卡密管理系统。核心优势包括:

1. **零成本**: 完全基于 GitHub 免费功能
2. **易部署**: 无需服务器，配置简单
3. **可扩展**: 支持自定义算法和业务逻辑
4. **安全可靠**: 多层安全机制保护数据

对于更复杂的业务场景，可以在此基础上添加后端服务和数据库，实现更强大的功能。
